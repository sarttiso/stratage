<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>stratage.stratage - stratage 1.1.0.post1.dev1+gc5f3bc7 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style>
  
  <script defer src="https://umami.ts-ht.com/script.js" data-website-id="0775ec1a-107e-4c73-ab7e-08325a4a5fac"></script>
</head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">stratage 1.1.0.post1.dev1+gc5f3bc7 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">stratage 1.1.0.post1.dev1+gc5f3bc7 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../toy-example.html">Toy Example</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api/modules.html">Module Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Module Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/stratage.html">stratage package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for stratage.stratage</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">arviz</span> <span class="k">as</span> <span class="nn">az</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize_scalar</span><span class="p">,</span> <span class="n">lsq_linear</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">pymc</span> <span class="k">as</span> <span class="nn">pm</span>
<span class="kn">import</span> <span class="nn">pytensor.tensor</span> <span class="k">as</span> <span class="nn">pt</span>
<span class="kn">from</span> <span class="nn">pytensor.graph</span> <span class="kn">import</span> <span class="n">Apply</span><span class="p">,</span> <span class="n">Op</span>

<span class="kn">from</span> <span class="nn">.geochron</span> <span class="kn">import</span> <span class="n">Geochron</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Adrian Tasistro-Hart&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Adrian Tasistro-Hart&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GPL-3.0-only&quot;</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="geochron_height_check">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.geochron_height_check">[docs]</a>
<span class="k">def</span> <span class="nf">geochron_height_check</span><span class="p">(</span><span class="n">unit_heights</span><span class="p">,</span> <span class="n">geochron_heights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that geochron heights are within units and not at contacts. Also ensure that geochron heights are within the section. Run before trimming section to the top and bottom of the geochron constraints.</span>

<span class="sd">    Args:</span>
<span class="sd">        unit_heights (numpy.ndarray): Bottom and top heights of units in section. </span>
<span class="sd">            2d array (nx2) of bottom and top heights for each of n units</span>
<span class="sd">        geochron_heights (arraylike): Heights of geochron constraints in the section</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If any of the geochron heights are below the section or above the section.</span>
<span class="sd">        AssertionError: If any of the geochron heights are at contacts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check that geochron heights are within the section</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">geochron_heights</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unit_heights</span><span class="p">)</span>
                  <span class="p">),</span> <span class="s1">&#39;geochron heights are below section&#39;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">geochron_heights</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unit_heights</span><span class="p">)</span>
                  <span class="p">),</span> <span class="s1">&#39;geochron heights are above section&#39;</span>
    <span class="c1"># check that geochron heights are not at contacts except for the top and bottom</span>
    <span class="n">offending_heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">geochron_heights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">unit_heights</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">offending_heights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
        <span class="sa">f</span><span class="s1">&#39;geochron heights cannot be at contacts, </span><span class="si">{</span><span class="n">offending_heights</span><span class="si">}</span><span class="s1">&#39;</span></div>



<div class="viewcode-block" id="trim_units">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.trim_units">[docs]</a>
<span class="k">def</span> <span class="nf">trim_units</span><span class="p">(</span><span class="n">unit_heights</span><span class="p">,</span> <span class="n">geochron_heights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim the top and bottom of the section to the top and bottom of the geochron constraints. Run after geochron_height_check.</span>

<span class="sd">    Args:</span>
<span class="sd">        unit_heights (numpy.ndarray): Bottom and top heights of units in section. </span>
<span class="sd">            2d array-like (nx2) of bottom and top heights for each of n units</span>
<span class="sd">        geochron_heights (arraylike): Heights of geochron constraints in section</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Trimmed unit heights after adjusting for the top and bottom units</span>

<span class="sd">    Raises:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">geochron_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">geochron_heights</span><span class="p">)</span>
    <span class="n">geochron_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">geochron_heights</span><span class="p">)</span>

    <span class="n">below_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">unit_heights</span> <span class="o">&lt;</span> <span class="n">geochron_top</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">above_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">unit_heights</span> <span class="o">&gt;</span> <span class="n">geochron_bottom</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">n_trimmed_units</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">below_idx</span> <span class="o">&amp;</span> <span class="n">above_idx</span><span class="p">))</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trimmed </span><span class="si">{</span><span class="n">n_trimmed_units</span><span class="si">}</span><span class="s2"> units outside of geochron constraints.&quot;</span><span class="p">)</span>

    <span class="n">unit_heights_trim</span> <span class="o">=</span> <span class="n">unit_heights</span><span class="p">[</span><span class="n">below_idx</span> <span class="o">&amp;</span> <span class="n">above_idx</span><span class="p">]</span>

    <span class="c1"># adjust heights for the top and bottom units</span>
    <span class="n">unit_heights_trim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">geochron_top</span>
    <span class="n">unit_heights_trim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">geochron_bottom</span>

    <span class="k">return</span> <span class="n">unit_heights_trim</span></div>



<div class="viewcode-block" id="get_times">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.get_times">[docs]</a>
<span class="k">def</span> <span class="nf">get_times</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floating times array for units.</span>

<span class="sd">    Args:</span>
<span class="sd">        sed_rates (arraylike): Sedimentation rates for each unit</span>
<span class="sd">        hiatuses (arraylike): Hiatuses between units</span>
<span class="sd">        units (numpy.ndarray): Bottom and top heights of units in section. </span>
<span class="sd">            2d array (nx2) of bottom and top heights for each of n units</span>

<span class="sd">    Returns:</span>
<span class="sd">        times (numpy.ndarray): Floating times array for units, same shape as units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_units</span><span class="p">,</span> <span class="s1">&#39;must have sed rate for each unit&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hiatuses</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_units</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;must have n_units-1 hiatuses&#39;</span>

    <span class="c1"># unit thicknesses</span>
    <span class="n">thicks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># time in each unit</span>
    <span class="n">unit_times</span> <span class="o">=</span> <span class="n">thicks</span><span class="o">/</span><span class="n">sed_rates</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_units</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">times</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">unit_times</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">times</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">hiatuses</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">unit_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">times</span></div>



<div class="viewcode-block" id="sigmoid">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.sigmoid">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sigmoid function for numerical stability.</span>

<span class="sd">    Args:</span>
<span class="sd">        t (float | arraylike): Value to apply sigmoid to.</span>
<span class="sd">        scale (float, optional): Transition width scale of sigmoid. Defaults to 0.001.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float | arraylike: Sigmoid applied to t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">scale</span><span class="p">))</span></div>



<div class="viewcode-block" id="DT_logp_l_gen">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.DT_logp_l_gen">[docs]</a>
<span class="k">def</span> <span class="nf">DT_logp_l_gen</span><span class="p">(</span><span class="n">pdt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a log-probability function for a numerical time increment distribution. Returned function interpolates a log probability and takes as inputs time increment(s) at which to evaluate as well as (required) time increment coordinates corresponding to the numerical pdf associated with the function. Sped up with numba.</span>

<span class="sd">    Args:</span>
<span class="sd">        pdt (array-like): The probability density function values for the time increments.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numba.core.registry.CPUDispatcher: A function that computes the log-probability of a given time increment.</span>
<span class="sd">            The returned function, DT_logp, takes the following parameters:</span>
<span class="sd">                dt_query (float): The time increment for which the log-probability is to be computed.</span>
<span class="sd">                dt (array-like): The array of time increments corresponding to the probability density function values. Must be same length as pdt.</span>
<span class="sd">            The DT_logp function computes the log-probability by interpolating the probability density function values and applying sigmoid functions to ensure the values are within the valid range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@njit</span>
    <span class="k">def</span> <span class="nf">DT_logp</span><span class="p">(</span><span class="n">dt_query</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dt_query</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">pdt</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">dt_query</span><span class="o">-</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dt_query</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DT_logp</span></div>



<div class="viewcode-block" id="randlike_gen">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.randlike_gen">[docs]</a>
<span class="k">def</span> <span class="nf">randlike_gen</span><span class="p">(</span><span class="n">geochron</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate function for generating random draws from likelihood. Permits generating prior_predictive samples from a model with the CustomDist likelihood.</span>

<span class="sd">    Args:</span>
<span class="sd">        geochron (geochron.Geochron): Geochron object containing geochronologic constraints.</span>
<span class="sd">        units (numpy.ndarray): Bottom and top heights of units in section. </span>
<span class="sd">            2d array (nx2) of bottom and top heights for each of n units</span>

<span class="sd">    Returns:</span>
<span class="sd">        function: Function for generating random draws from likelihood.</span>
<span class="sd">            The returned function, eps_rand, takes the following parameters:</span>
<span class="sd">                | params (array-like): Array of parameters; concatenation of sedimentation rates and hiatuses.</span>
<span class="sd">                | rng (numpy.random.Generator): Random number generator.</span>
<span class="sd">                | size (int or tuple of ints, optional): Output shape. Default is None. Last dimension must be the number of pairs of geochron constraints.</span>
<span class="sd">            The function returns a numpy.ndarray of random draws.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">model_weights</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eps_rand</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate random samples from likelihood. Params is the concatenation of sedimentation rates and hiatuses.</span>

<span class="sd">        Args:</span>
<span class="sd">            params (array-like): Array of parameters; concatenation of sedimentation rates and hiatuses.</span>
<span class="sd">            rng (numpy.random.Generator): Random number generator.</span>
<span class="sd">            size (int or tuple of ints, optional): Output shape. Default is None. Last dimension must be the number of pairs of geochron constraints.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Random draws.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If size is incompatible with the number of pairs.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The function calculates the random draws based on the given parameters and geochron constraints.</span>
<span class="sd">            - If size is not provided or is None, it will default to the number of pairs.</span>
<span class="sd">            - If there is only one pair, the geochron dt will be shifted for the current dt_max.</span>
<span class="sd">            - If there are multiple pairs, the geochron dt for each pair will be shifted for the corresponding dt_max.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sed_rates</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_units</span><span class="p">]</span>
        <span class="n">hiatuses</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">n_units</span><span class="p">:]</span>
        <span class="n">dt_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">sed_rates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">hiatuses</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># print(size)</span>
        <span class="k">if</span> <span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span><span class="p">,</span> <span class="s1">&#39;size incompatible with ys, DTs&#39;</span>
        <span class="k">if</span> <span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># shift geochron dt for current dt_max</span>
            <span class="n">cur_dt</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">dts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_hat</span>
            <span class="n">CDF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">pdts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cur_dt</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">),</span> <span class="n">CDF</span><span class="p">,</span> <span class="n">cur_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span><span class="p">):</span>
                <span class="c1"># shift geochron dt for current dt_max</span>
                <span class="n">cur_dt</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">dts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_hat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">CDF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">pdts</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cur_dt</span><span class="p">))</span>
                <span class="n">rand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">CDF</span><span class="p">,</span> <span class="n">cur_dt</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eps_rand</span></div>



<div class="viewcode-block" id="loglike_gen">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.loglike_gen">[docs]</a>
<span class="k">def</span> <span class="nf">loglike_gen</span><span class="p">(</span><span class="n">geochron</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns log-likelihood object for use in PyMC.CustomDist as a likelihood for posterior sampling. See subfunction eps_logp for details on the log-likelihood computation.</span>

<span class="sd">    Args:</span>
<span class="sd">        geochron (geochron.Geochron): Geochron object containing geochronologic constraints.</span>
<span class="sd">        units (ndarray): nx2 array of unit bottom and top heights for n units.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LogLike: PyTensor Op class for likelihood evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># model weights</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">model_weights</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
    <span class="n">n_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># time increment log-probability functions</span>
    <span class="n">DT_logps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span><span class="p">):</span>
        <span class="n">DT_logps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DT_logp_l_gen</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">pdts</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">eps_logp</span><span class="p">(</span><span class="n">dt_val</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the log-probability for the deviation from the maximum likelihood time increment values for each pair of constraints. This function is designed to be evaluated at zero (dt_val = 0). Params contains the sedimentation rates and hiatuses for the stratigraphy. For a given params, the corresponding time increments (dt_hat) are computed for each pair. If they are near the true maximum likelihood time increments (geochron.dts_max), then evaluation at dt_val = 0 will return the highest likelihood. If any dt_hat is near zero, then dt_val=0 evaluates near dt=0 (for the true time increment), which has to be small since the time increments must be positive. The log-probability is computed by interpolating the numerical time increment functions and applying a sigmoid function to ensure the values are within a valid range.</span>

<span class="sd">        Args:</span>
<span class="sd">            dt_val (array-like): The observed DT values.</span>
<span class="sd">            params (array-like): Model parameters as concatenation of sedimentation rates and hiatuses.</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The log-probability values for each pair of DT values.</span>
<span class="sd">        Notes:</span>
<span class="sd">            - `geochron.n_pairs` is used to determine the number of DT pairs.</span>
<span class="sd">            - The function computes `dt_hat` using sedimentation rates and hiatuses.</span>
<span class="sd">            - The log-probability is calculated by interpolating the observed DT values </span>
<span class="sd">            and applying a sigmoid function to ensure the values are within a valid range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span>
        <span class="c1"># logp = 0</span>
        <span class="n">logp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">sed_rates</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_units</span><span class="p">]</span>
        <span class="n">hiatuses</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">n_units</span><span class="p">:]</span>
        <span class="c1"># compute dt_hat</span>
        <span class="n">dt_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">sed_rates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">hiatuses</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># shift geochron dt for current dt_hat</span>
            <span class="n">cur_dt</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">dts</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_hat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="n">logp</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">DT_logps</span><span class="p">[</span><span class="n">ii</span><span class="p">](</span><span class="n">dt_val</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">cur_dt</span><span class="p">)</span>
            <span class="c1"># logp[ii] = np.log(np.interp(dt_val[ii], cur_dt, geochron.pdts[ii]) * \</span>
            <span class="c1">#                   sigmoid(dt_val[ii]-cur_dt[0]) * \</span>
            <span class="c1">#                   sigmoid(cur_dt[-1]-dt_val[ii]))</span>
            <span class="c1"># logp += cur_logp_fun(t[ii])</span>
        <span class="k">return</span> <span class="n">logp</span>

    <span class="k">class</span> <span class="nc">LogLike</span><span class="p">(</span><span class="n">Op</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;blackbox&quot; likelihood class for PyMC which enables use of eps_logp as a likelihood for sampling.</span>

<span class="sd">        Args:</span>
<span class="sd">            Op (pystensor.graph.Op): PyTensor Op class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">make_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt_val</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Apply</span><span class="p">:</span>
            <span class="n">dt_val</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">dt_val</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt_val</span><span class="p">,</span> <span class="n">params</span><span class="p">]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt_val</span><span class="o">.</span><span class="n">type</span><span class="p">()]</span>
            <span class="k">return</span> <span class="n">Apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Apply</span><span class="p">,</span>
                    <span class="n">inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                    <span class="n">outputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt_val</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">inputs</span>
            <span class="n">loglike_eval</span> <span class="o">=</span> <span class="n">eps_logp</span><span class="p">(</span><span class="n">dt_val</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loglike_eval</span><span class="p">)</span>

    <span class="n">loglike_op</span> <span class="o">=</span> <span class="n">LogLike</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">loglike_op</span></div>



<div class="viewcode-block" id="floating_age">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.floating_age">[docs]</a>
<span class="k">def</span> <span class="nf">floating_age</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">heights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating ages at heights in strat. Assumes t=0 at base of section. Times at contact heights are returned as the age of the top of the unit below the contact.</span>

<span class="sd">    Args:</span>
<span class="sd">        sed_rates (arraylike): Sedimentation rates for each unit.</span>
<span class="sd">        hiatuses (arraylike): Hiatuses between units. Must be len(sed_rates)-1.</span>
<span class="sd">        units (arraylike): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">        heights (arraylike | float): Height(s) at which to evaluate the age model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: Age(s) at the given height(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># floating age model</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">get_times</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">age</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">heights</span><span class="p">)</span></div>



<div class="viewcode-block" id="age">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.age">[docs]</a>
<span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">heights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate time at given heights in strat. Times at contact heights are returned as the age of the top of the unit below the contact.</span>

<span class="sd">    Args:</span>
<span class="sd">        times (arraylike): nx2 array of unit bottom and top times for n units.</span>
<span class="sd">        units (arraylike): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">        heights (arraylike): Height(s) at which to evaluate the age model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: Age(s) at the given height(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
    <span class="n">n_heights</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
    <span class="c1"># confirm that heights are within units</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">heights</span> <span class="o">&gt;=</span> <span class="n">units</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
        <span class="n">heights</span> <span class="o">&lt;=</span> <span class="n">units</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="s1">&#39;heights must be within units&#39;</span>
    <span class="c1"># evaluate cumulative time at height</span>
    <span class="n">ages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_heights</span><span class="p">)</span>
    <span class="c1"># indices into units and times of each height</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">((</span><span class="n">heights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">units</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                     <span class="p">(</span><span class="n">heights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">units</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">height</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">heights</span><span class="p">):</span>
        <span class="c1"># otherwise linearly interpolate sed rate in the unit</span>
        <span class="n">ages</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">units</span><span class="p">[</span><span class="n">idxs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="p">:],</span> <span class="n">times</span><span class="p">[</span><span class="n">idxs</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="n">ages</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>



<div class="viewcode-block" id="fit_floating_model">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.fit_floating_model">[docs]</a>
<span class="k">def</span> <span class="nf">fit_floating_model</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">geochron</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fit a floating age model to geochronologic constraints </span>
<span class="sd">    </span>
<span class="sd">    Two methods are implemented. One (method=&#39;max&#39;) maximizes the likelihood of alignment with the geochronologic constraints by using scipy.optimize.minimize_scalar to minimize the negative log likelihood of a time offset with respect to the distributions in absolute time of the geochronologic constraints.</span>
<span class="sd">    </span>
<span class="sd">    The other (method=&#39;random&#39;) samples from the total alignment likelihood and selects a random offset that is consistent with the likelihood. This method is the default.</span>

<span class="sd">    Args:</span>
<span class="sd">        sed_rates (arraylike): Sedimentation rates for each unit.</span>
<span class="sd">        hiatuses (arraylike): Hiatuses between units. Must be len(sed_rates)-1.</span>
<span class="sd">        units (ndarray): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">        geochron (geochron.Geochron): Geochron object containing geochron constraints.</span>
<span class="sd">        tol (float, optional): Tolerance for bounds on optimization. Defaults to 1e-6.</span>
<span class="sd">        method (str, optional): Method for optimization. &#39;max&#39; for maximum likelihood, &#39;random&#39; for random sampling of alignment likelihood. Defaults to &#39;random&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: nx2 array of unit bottom and top ages for n units in absolute time</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check that geochron heights are not at contacts</span>
    <span class="k">assert</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">units</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="s1">&#39;heights cannot be at contacts&#39;</span>

    <span class="c1"># floating age model</span>
    <span class="n">geochron_float_ages</span> <span class="o">=</span> <span class="n">floating_age</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">geochron</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">time_offset_cost</span><span class="p">(</span><span class="n">offset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cost function to optimize to find the shift in cumulative times that best fits the geochronologic constraints. The goal is to maximize the log likelihood, which is equivalent to minimizing the negative log likelihood.</span>
<span class="sd">        Args:</span>
<span class="sd">            offset (float): The offset to apply to floating ages; optimization parameter.</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: The negative log likelihood value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log likelihood</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_constraints</span><span class="p">):</span>
            <span class="n">ll</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">geochron_float_ages</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ll</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="c1"># get the offset to optimally align the depth-time history</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">time_offset_cost</span><span class="p">,</span>
                                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bounded&#39;</span><span class="p">,</span>
                                <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">tol</span><span class="p">),</span>
                                        <span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">tol</span><span class="p">)])</span><span class="o">.</span><span class="n">x</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
        <span class="c1"># ranges constrain interval of possible offsets based on geochron constraints</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span> <span class="p">[</span><span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span> <span class="o">-</span> <span class="n">geochron_float_ages</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> 
                              <span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="o">-</span> <span class="n">geochron_float_ages</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> 
                              <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_constraints</span><span class="p">)])</span>
        <span class="n">t_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">cur_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">time_offset_cost</span><span class="p">(</span><span class="n">t_offset</span><span class="p">))</span>
        <span class="n">cur_cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cur_like</span><span class="p">)</span> <span class="c1"># cumulative distribution function</span>
        <span class="n">cur_cdf</span> <span class="o">=</span> <span class="n">cur_cdf</span><span class="o">/</span><span class="n">cur_cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># normalize to unit probability</span>
        <span class="n">cur_cdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># probability starts at 0</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(),</span> <span class="n">cur_cdf</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">)</span> <span class="c1"># use inverse transform sampling to sample offset</span>

    <span class="c1"># floating age model</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">get_times</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">times</span> <span class="o">+</span> <span class="n">offset</span></div>



<div class="viewcode-block" id="age_depth">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.age_depth">[docs]</a>
<span class="k">def</span> <span class="nf">age_depth</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert units, times arrays to age-depth curve</span>

<span class="sd">    Args:</span>
<span class="sd">        units (numpy.ndarray): An nx2 array of bottom and top elevations for each of n units.</span>
<span class="sd">        times (numpy.ndarray): An nx2 array of bottom and top times for each of n units.</span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Vector of ages for each unit.</span>
<span class="sd">        numpy.ndarray: Vector of heights for each unit.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">z</span></div>



<div class="viewcode-block" id="model_ls">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.model_ls">[docs]</a>
<span class="k">def</span> <span class="nf">model_ls</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">geochron</span><span class="p">,</span>
             <span class="n">sed_rate_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">hiatus_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Least squares age model fitting.</span>

<span class="sd">    Args:</span>
<span class="sd">        units (ndarray): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">        geochron (geochron.Geochron): Geochron object containing geochron constraints.</span>
<span class="sd">        sed_rate_bounds (list, optional): Bounds on sedimentation rates. Defaults to None.</span>
<span class="sd">        hiatus_bounds (list, optional): Bounds on hiatuses. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sed_rates (numpy.ndarray): Sedimentation rates for each unit.</span>
<span class="sd">        hiatuses (numpy.ndarray): Hiatuses between units.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">geochron</span><span class="o">.</span><span class="n">model_weights</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
    <span class="c1"># model matrix</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">dts_max</span><span class="p">)</span>

    <span class="n">n_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_contacts</span> <span class="o">=</span> <span class="n">n_units</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># set defaults for bounds</span>
    <span class="k">if</span> <span class="n">sed_rate_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sed_rate_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">hiatus_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hiatus_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>

    <span class="c1"># bounds on model parameters</span>
    <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_units</span><span class="o">+</span><span class="n">n_contacts</span><span class="p">)</span>
    <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_units</span><span class="o">+</span><span class="n">n_contacts</span><span class="p">)</span>
    <span class="c1"># units</span>
    <span class="n">lower_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_units</span><span class="p">]</span> <span class="o">=</span> <span class="n">sed_rate_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">upper_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_units</span><span class="p">]</span> <span class="o">=</span> <span class="n">sed_rate_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># contacts</span>
    <span class="n">lower_bounds</span><span class="p">[</span><span class="n">n_units</span><span class="p">:]</span> <span class="o">=</span> <span class="n">hiatus_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">upper_bounds</span><span class="p">[</span><span class="n">n_units</span><span class="p">:]</span> <span class="o">=</span> <span class="n">hiatus_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># least squares</span>
    <span class="n">m_bdls</span> <span class="o">=</span> <span class="n">lsq_linear</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">])</span>
    <span class="n">m_bdls_sol</span> <span class="o">=</span> <span class="n">m_bdls</span><span class="o">.</span><span class="n">x</span>
    <span class="c1"># m_bdls_res = m_bdls.fun</span>
    <span class="n">sed_rates</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">m_bdls_sol</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_units</span><span class="p">]</span>
    <span class="n">hiatuses</span> <span class="o">=</span> <span class="n">m_bdls_sol</span><span class="p">[</span><span class="n">n_units</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span></div>



<div class="viewcode-block" id="AgeModel">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.AgeModel">[docs]</a>
<span class="k">class</span> <span class="nc">AgeModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Age model object for Bayesian inference of sedimentation rates and hiatuses.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        units (numpy.ndarray): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">        geochron (geochron.Geochron): Geochron object containing geochron constraints.</span>
<span class="sd">        sed_rates_prior (function): Prior distribution for sedimentation rates. Must be valid as dist argument to pymc.CustomDist(dist=dist). Signature is sed_rate_prior(size=size).</span>
<span class="sd">        hiatuses_prior (function): Prior distribution for hiatuses. Must be valid as dist argument to pymc.CustomDist(dist=dist). Signature is hiatus_prior(size=size).</span>
<span class="sd">        n_units (int): Number of units.</span>
<span class="sd">        n_contacts (int): Number of contacts.</span>
<span class="sd">        units_trim (numpy.ndarray): Trimmed unit heights after adjusting for the top and bottom units.</span>
<span class="sd">        sed_rates_ls (numpy.ndarray): Sedimentation rates from least squares model.</span>
<span class="sd">        hiatuses_ls (numpy.ndarray): Hiatuses from least squares model.</span>
<span class="sd">        model (pymc.Model): PyMC model object for Bayesian inference.</span>
<span class="sd">        vars_list (list): List of variables in the pymc.model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">geochron</span><span class="p">,</span> <span class="n">sed_rates_prior</span><span class="p">,</span> <span class="n">hiatuses_prior</span><span class="p">,</span> <span class="n">ls_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes age model object for Bayesian inference of sedimentation rates and hiatuses.</span>

<span class="sd">        Args:</span>
<span class="sd">            units (numpy.ndarray): nx2 array of unit bottom and top heights for n units.</span>
<span class="sd">            geochron (geochron.Geochron): Geochron object containing geochron constraints.</span>
<span class="sd">            sed_rates_prior (function): Prior distribution for sedimentation rates. Must be valid as dist argument to pymc.CustomDist(dist=dist). Signature is sed_rate_prior(size=size).</span>
<span class="sd">            hiatuses_prior (function): Prior distribution for hiatuses. Must be valid as dist argument to pymc.CustomDist(dist=dist). Signature is hiatus_prior(size=size).</span>
<span class="sd">            ls_kwargs (dict, optional): Keyword arguments for model_ls. Defaults to None. If None, empty dictionary is passed to model_ls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assign attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span> <span class="o">=</span> <span class="n">geochron</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sed_rates_prior</span> <span class="o">=</span> <span class="n">sed_rates_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hiatuses_prior</span> <span class="o">=</span> <span class="n">hiatuses_prior</span>
        
        <span class="c1"># number of units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># number of contacts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_contacts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_units</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># confirm that geochron heights are within the section</span>
        <span class="n">geochron_height_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># trim the section to the top and bottom of the geochron constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span> <span class="o">=</span> <span class="n">trim_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># create least squares model as initial guess</span>
        <span class="k">if</span> <span class="n">ls_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ls_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sed_rates_ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hiatuses_ls</span> <span class="o">=</span> <span class="n">model_ls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">,</span> <span class="o">**</span><span class="n">ls_kwargs</span><span class="p">)</span>
        <span class="c1"># create time increment log-like function</span>
        <span class="n">loglike_op</span> <span class="o">=</span> <span class="n">loglike_gen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">)</span>
        <span class="c1"># create time increment random-like function</span>
        <span class="n">rand_op</span> <span class="o">=</span> <span class="n">randlike_gen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">)</span>
        <span class="c1"># create model</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_units</span><span class="p">),</span>
                <span class="s1">&#39;contacts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_contacts</span><span class="p">),</span>
                <span class="s1">&#39;pairs&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">:</span>
            <span class="c1"># sed rates</span>
            <span class="n">sed_rates</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">CustomDist</span><span class="p">(</span><span class="s1">&#39;sed_rates&#39;</span><span class="p">,</span>
                                    <span class="n">dist</span><span class="o">=</span><span class="n">sed_rates_prior</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_units</span><span class="p">,),</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">set_initval</span><span class="p">(</span><span class="n">sed_rates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sed_rates_ls</span><span class="p">)</span>
            <span class="c1"># hiatuses</span>
            <span class="n">hiatuses</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">CustomDist</span><span class="p">(</span><span class="s1">&#39;hiatuses&#39;</span><span class="p">,</span>
                                    <span class="n">dist</span><span class="o">=</span><span class="n">hiatuses_prior</span><span class="p">,</span>
                                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_contacts</span><span class="p">,),</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;contacts&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">set_initval</span><span class="p">(</span><span class="n">hiatuses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hiatuses_ls</span><span class="p">)</span>
            <span class="c1"># likelihood</span>
            <span class="n">likelihood</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">CustomDist</span><span class="p">(</span><span class="s1">&#39;likelihood&#39;</span><span class="p">,</span>
                                    <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sed_rates</span><span class="p">,</span> <span class="n">hiatuses</span><span class="p">]),</span>
                                    <span class="n">observed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="o">.</span><span class="n">n_pairs</span><span class="p">),</span>
                                    <span class="n">logp</span><span class="o">=</span><span class="n">loglike_op</span><span class="p">,</span>
                                    <span class="n">random</span><span class="o">=</span><span class="n">rand_op</span><span class="p">)</span>
        <span class="c1"># variable list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">values_to_rvs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
<div class="viewcode-block" id="AgeModel.sample_prior">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.AgeModel.sample_prior">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draws</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample prior predictive distribution of age models.</span>

<span class="sd">        Args:</span>
<span class="sd">            draws (int, optional): Number of prior predictive draws. Defaults to 100.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of prior predictive samples of times; each element is a nx2 array of unit bottom and top times for n units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sample prior</span>
        <span class="n">prior_params</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample_prior_predictive</span><span class="p">(</span><span class="n">draws</span><span class="o">=</span><span class="n">draws</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">prior</span>
        <span class="c1"># numpy arrays</span>
        <span class="n">sed_rates_prior</span> <span class="o">=</span> <span class="n">prior_params</span><span class="o">.</span><span class="n">sed_rates</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">hiatuses_prior</span> <span class="o">=</span> <span class="n">prior_params</span><span class="o">.</span><span class="n">hiatuses</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="c1"># get times</span>
        <span class="n">times_prior</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># mean age of lowest geochron constraint</span>
        <span class="n">mean_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="o">.</span><span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span>
        <span class="c1"># iterate over draws to generate times</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">draws</span><span class="p">):</span>
            <span class="c1"># attempt to fit floating model</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="n">cur_time</span> <span class="o">=</span> <span class="n">fit_floating_model</span><span class="p">(</span><span class="n">sed_rates_prior</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                                                  <span class="n">hiatuses_prior</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> 
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">,</span> 
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">)</span>
            <span class="c1"># if fit fails, use floating model pinned to mean age of lowest geochron constraint</span>
            <span class="k">except</span> <span class="ne">RuntimeWarning</span><span class="p">:</span>
                <span class="n">cur_time</span> <span class="o">=</span> <span class="n">get_times</span><span class="p">(</span><span class="n">sed_rates_prior</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> 
                                     <span class="n">hiatuses_prior</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_age</span>
            <span class="n">times_prior</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times_prior</span></div>

    
<div class="viewcode-block" id="AgeModel.sample">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.AgeModel.sample">[docs]</a>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">draws</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample posterior distribution of sedimentation rates and hiatus durations.</span>

<span class="sd">        The output of this function must be transformed to age models.</span>

<span class="sd">        Args:</span>
<span class="sd">            draws (int, optional): Number of posterior draws. Defaults to 1000.</span>

<span class="sd">        Returns:</span>
<span class="sd">            arviz.InferenceData: ArviZ InferenceData object containing the MCMC trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sample</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">draws</span><span class="o">=</span><span class="n">draws</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trace</span></div>

    
<div class="viewcode-block" id="AgeModel.fit_absolute_age">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.AgeModel.fit_absolute_age">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fit_absolute_age</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">sed_rates_post</span><span class="p">,</span> <span class="n">hiatuses_post</span><span class="p">,</span> <span class="n">units_trim</span><span class="p">,</span> <span class="n">geochron</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the age model for the ii-th sample of the posterior.</span>

<span class="sd">        Static method to work with joblib.Parallel.</span>

<span class="sd">        Args:</span>
<span class="sd">            ii (int): Index of the posterior sample.</span>
<span class="sd">            sed_rates_post (ndarray): Sedimentation rates for each unit, ii-th posterior sample.</span>
<span class="sd">            hiatuses_post (ndarray): Hiatuses between units, ii-th posterior sample.</span>
<span class="sd">            units_trim (ndarray): Trimmed unit heights after adjusting for the top and bottom units.</span>
<span class="sd">            geochron (Geochron): Geochron object containing geochron constraints.</span>
<span class="sd">            h (arraylike): Heights at which to evaluate the age model.</span>
<span class="sd">            method (str): Method for optimization in fit_floating_model(). &#39;max&#39; for maximum likelihood, &#39;random&#39; for random sampling of alignment likelihood. </span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: Ages at the given height(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Logic for fitting the age model for the ii-th sample</span>
        <span class="n">cur_times</span> <span class="o">=</span> <span class="n">fit_floating_model</span><span class="p">(</span><span class="n">sed_rates_post</span><span class="p">,</span>
                                       <span class="n">hiatuses_post</span><span class="p">,</span>
                                       <span class="n">units_trim</span><span class="p">,</span>
                                       <span class="n">geochron</span><span class="p">,</span> 
                                       <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">age</span><span class="p">(</span><span class="n">cur_times</span><span class="p">,</span> <span class="n">units_trim</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="AgeModel.trace2ages">
<a class="viewcode-back" href="../../api/stratage.html#stratage.stratage.AgeModel.trace2ages">[docs]</a>
    <span class="k">def</span> <span class="nf">trace2ages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n_posterior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform MCMC trace to age models.</span>

<span class="sd">        Args:</span>
<span class="sd">            trace (arviz.InferenceData): ArviZ InferenceData object containing the MCMC trace.</span>
<span class="sd">            h (arraylike): Heights at which to evaluate the age model. </span>
<span class="sd">            n_posterior (int, optional): Number of posterior samples. Defaults to None.</span>
<span class="sd">            n_jobs (int, optional): Number of parallel jobs. Defaults to 1. If 1, no parallelization is used. Uses joblib.Parallel for parallelization.</span>
<span class="sd">            method (str, optional): Method for optimization in fit_floating_model(). &#39;max&#39; for maximum likelihood, &#39;random&#39; for random sampling of alignment likelihood. Defaults to &#39;random&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of age models; each element is a nx2 array of unit bottom and top times for n units.</span>
<span class="sd">            numpy.ndarray: Array of age models at heights h; each row is an age model. Shape is (n_posterior, len(h)). Only returned if h is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_chain</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">size</span>
        <span class="n">n_draws</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># if n_posterior is None, take min of 10,000 and chain*draws</span>
        <span class="k">if</span> <span class="n">n_posterior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_posterior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">10000</span><span class="p">,</span> <span class="n">n_chain</span><span class="o">*</span><span class="n">n_draws</span><span class="p">])</span>
        <span class="n">posterior_params</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">n_posterior</span><span class="p">)</span>
        <span class="c1"># get posterior samples</span>
        <span class="n">sed_rates_post</span> <span class="o">=</span> <span class="n">posterior_params</span><span class="o">.</span><span class="n">sed_rates</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">hiatuses_post</span> <span class="o">=</span> <span class="n">posterior_params</span><span class="o">.</span><span class="n">hiatuses</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># get ages at heights h</span>
        <span class="n">t_post</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># iterate over posterior samples to generate times</span>
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_posterior</span><span class="p">),</span> 
                        <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Anchoring floating age models&#39;</span><span class="p">):</span>
                <span class="n">t_post</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_absolute_age</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> 
                                                    <span class="n">sed_rates_post</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span> 
                                                    <span class="n">hiatuses_post</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">,</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">,</span>
                                                    <span class="n">h</span><span class="p">,</span>
                                                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_post</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_absolute_age</span><span class="p">)(</span><span class="n">ii</span><span class="p">,</span> 
                                                                            <span class="n">sed_rates_post</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span>
                                                                            <span class="n">hiatuses_post</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">units_trim</span><span class="p">,</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">geochron</span><span class="p">,</span>
                                                                            <span class="n">h</span><span class="p">,</span>
                                                                            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> \
                                             <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_posterior</span><span class="p">),</span>
                                                            <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Anchoring floating age models&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">t_post</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Adrian Tasistro-Hart
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=e0dbd34f"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>